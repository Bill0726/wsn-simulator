package protocols.DCF;

import WSN.Node;
import WSN.WSN;
import WSN.Scheduler;
import WSN.Packet;
import protocols.Event;


import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Random;

/**
 * Created by gianluca on 28/07/17.
 */
public class StartListeningEvent extends Event {


    public StartListeningEvent(Node n, double time){
        super(n, time, WSN.listenColor);
    }

    public void run(){

        super.run();

        Scheduler scheduler = Scheduler.getInstance();

        // // Packet generation process. At each StartListening event a new packet is generated by the node and it remains in the node queue until it will be successfully delivered.
        //  N.B. I'm not sure that this is the optimal place to put the random generation procedure...

            Random rand = new Random();
            ArrayList<Node> neighbors = this.n.getNeighborList();
            Packet p = new Packet(null, null);
            try {
                p = new Packet(n, neighbors.get(rand.nextInt(neighbors.size())));
            }
            catch (java.lang.IllegalArgumentException e){
                System.out.println("Error! There are one or more nodes with no one neighbor! \nSystem exit... ");
                System.exit(1);
            }
            // the packet is enqueued into the node
            n.enqueuePacket(p);
            if(WSN.debug) { System.out.println("Next packet destination: Node "+n.getNextPacket().getDestination().getId()); }

        // //

        LinkedList<Node> transmittingNodes = WSN.getNeighborsStatus(this.n, WSN.NODE_STATUS.TRANSMITTING);

        if (WSN.debug){
            if(transmittingNodes.isEmpty()) { System.out.println("Channel is free. BO counter: " + n.getBOcounter());
            }else { System.out.println("Channel is busy. BO counter: " + n.getBOcounter());}
        }

        n.setStatus(WSN.NODE_STATUS.LISTENING);

        if (transmittingNodes.isEmpty()){
            n.freeChannel = true;
            scheduler.schedule(new CheckChannelStatus(n,time+WSN.DIFS, WSN.DIFS));
            // save transmission initial time (useful to Delay)
            this.n.startTXTime(time);
        }
    }

    @Override
    public String toString(){
        return "[" + time + "][StartListeningEvent] from node " +  this.n;
    }
}
